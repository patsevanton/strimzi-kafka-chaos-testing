# Критика метода проверки доставки через Redis (хеш + счётчики)

Реализованная схема: Producer пишет в Kafka и в Redis (ключ = ключ сообщения, значение = **content hash (id+data)** + timestamp). Consumer сверяет только хеш полей id и data; различие по timestamp (ретраи, дубликаты) не считается несовпадением. При совпадении content hash - удаление ключа и счётчик полученных. При несовпадении тела (другие id или data) - ошибка в логе и метрика `kafka_consumer_redis_hash_mismatch_total`. SLO считается по доле сообщений, «оставшихся» в Redis дольше заданного времени.

## Плюсы

- **Проверка целостности**: сравнение хеша позволяет обнаружить искажение тела сообщения в пути (Kafka, сеть, код).
- **Факт доставки**: удаление из Redis после успешной обработки даёт явный сигнал «сообщение доставлено и проверено».
- **SLO по задержке доставки**: счётчик «старых» pending-ключей (старше N секунд) даёт метрику нарушения SLO по времени доставки.

## Минусы и риски

### 1. Два хранилища (Kafka + Redis)

- Запись в Kafka и в Redis не в одной транзакции. Если после успешной отправки в Kafka запись в Redis не удалась (сеть, падение процесса), в Kafka сообщение есть, в Redis - нет. Consumer получит сообщение, не найдёт ключ в Redis и не сможет ни верифицировать, ни удалить «ожидающее» сообщение. Теряется однозначность: «нет в Redis» может означать «ещё не записали» или «уже обработали».
- Рекомендация: при недоступности Redis на Producer либо не считать сообщение «ожидающим» (и не увеличивать sent в Redis), либо иметь отдельный канал алертов и метрик по ошибкам записи в Redis.

### 2. Порядок операций Producer

- Сейчас: сначала `WriteMessages`, потом Redis SET. Если процесс падает между ними, в Kafka сообщение есть, в Redis - нет. При обратном порядке (сначала Redis, потом Kafka) при падении после Redis и до Kafka в Redis останутся «сироты», которые никогда не будут удалены (сообщение в Kafka не появится). Текущий порядок (Kafka → Redis) лучше для консистентности «в Kafka есть ⇒ ожидаем в Redis», но усиливает зависимость от надёжности записи в Redis после Kafka.

### 3. Идемпотентность и повторная доставка

- При at-least-once consumer может обработать одно и то же сообщение дважды. При первой обработке ключ удаляется из Redis и увеличивается счётчик. При второй обработке ключа в Redis уже нет - нельзя отличить «дубликат доставки» от «producer не писал в Redis». Счётчик полученных сообщений может стать больше числа уникальных сообщений.
- Для идемпотентности нужна отдельная стратегия (дедупликация по ключу/идемпотентному ключу в другом хранилище), текущая схема это не решает.

### 4. Определение SLO

- «Оставшиеся сообщения в Redis дольше N секунд» - хороший индикатор задержки доставки, но:
  - **Один consumer group**: интерпретация однозначна - «ещё не обработано».
  - **Несколько топиков/приложений**: нужны разные префиксы/базы Redis, иначе счётчики смешиваются.
  - **Рост pending без роста old**: если consumer отстаёт, но все сообщения обрабатываются быстрее N секунд, SLO по «old» не нарушен, хотя задержка растёт. Имеет смысл смотреть и общее число pending, и old.
- Счётчик «received» в Redis считает факт обработки (и удаления из Redis), а не уникальные сообщения. При повторной доставке он завышается.

### 5. Масштабирование Producer

- Ключ сообщения сейчас `key-{messageID}`; при нескольких репликах Producer без координации messageID может пересекаться. Тогда один и тот же Redis-ключ перезаписывается разными сообщениями, верификация и SLO искажаются. Нужен глобально уникальный ключ (например, UUID или namespace + id).

### 6. TTL и утечка памяти

- Ключи в Redis без TTL накапливаются, если Consumer перестал обрабатывать или часть сообщений никогда не будет потреблена. Имеет смысл задавать TTL (например, 24 часа) как защиту от бесконечного роста. Тогда «просроченные» ключи исчезают сами и не попадают в метрику old - для SLO лучше явно считать old по timestamp в значении (как сделано) и опционально использовать TTL только для очистки.

### 7. Нагрузка на Redis

- Каждое сообщение: Producer - SET + INCR; Consumer - GET + DEL + INCR. Плюс периодический SCAN для SLO. При высокой частоте сообщений Redis становится критичным звеном; его отказ или задержки влияют на Producer/Consumer. Стоит мониторить latency Redis и иметь fallback-поведение (например, продолжать работу без записи в Redis с алертом).

## Итог

Схема полезна для **верификации целостности** и **оценки задержки доставки (SLO)** в тестовых и контролируемых сценариях. Для продакшена важно: уникальные ключи при нескольких producer, TTL или иная очистка «сирот», явная обработка недоступности Redis и понимание, что счётчик received не идемпотентен при повторной доставке.
